/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Author: thegraphicsgeek (https://sketchfab.com/thegraphicsgeek)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/pot-boy-elden-ring-76d23eb862f94822ad4f6ec9f76ada07
Title: Pot Boy (Elden Ring)
*/

import React, { useRef, useEffect,useState } from "react";
import { useGLTF, useAnimations } from "@react-three/drei";
import { useFrame, useThree } from "@react-three/fiber";
import circularPath from "./Curve"
import * as THREE from "three";
import { Sphere, Box3, Vector3 } from "three";
import potboyscene from "../assets/3D/portboy.glb";
const Potboy = ({ isRotating, setIsRotating, currentAnimation,setCurrentStage,stageClik, ...props }) => {
  const { gl, viewport } = useThree();
  const lastX = useRef(0);
  const lastY = useRef(0);
  const rotationSpeed = useRef({ x: 0, y: 0 });
  const dampingFactor = 0.95;
  
  // Handle pointer (mouse or touch) down event
  const handlePointerDown = (event) => {
    event.stopPropagation();
    event.preventDefault();
    setIsRotating(true);

    // Calculate the clientX based on whether it's a touch event or a mouse event
    const clientX = event.touches ? event.touches[0].clientX : event.clientX;

    // Store the current clientX position for reference
    lastX.current = clientX;

    const clientY = event.touches ? event.touches[0].clientY : event.clientY;
    lastY.current = clientY;
  };
  // Handle pointer (mouse or touch) up event
  const handlePointerUp = (event) => {
    event.stopPropagation();
    event.preventDefault();
    setIsRotating(false);
  };
  // Handle pointer (mouse or touch) move event
  // Handle pointer (mouse or touch) move event
  const handlePointerMove = (event) => {
    event.stopPropagation();
    event.preventDefault();
    if (isRotating) {
      const clientX = event.touches ? event.touches[0].clientX : event.clientX;
      const clientY = event.touches ? event.touches[0].clientY : event.clientY;

      // Calculate deltas for both X and Y movement
      const deltaX = (clientX - lastX.current) / viewport.width;
      const deltaY = (clientY - lastY.current) / viewport.height;

      // Update the island's rotation based on mouse/touch movement
      group.current.rotation.y += deltaX * 0.02 * Math.PI; // Y-axis rotation
      group.current.rotation.x += deltaY * 0.02 * Math.PI; // X-axis rotation

      // Update references for the last clientX and clientY positions
      lastX.current = clientX;
      lastY.current = clientY;

      // Update the rotation speed
      rotationSpeed.current = {
        x: deltaX * 0.01 * Math.PI,
        y: deltaY * 0.01 * Math.PI,
      };
    }
  };
  // Touch events for mobile devices
  const handleTouchStart = (e) => {
    e.stopPropagation();
    e.preventDefault();
    setIsRotating(true);

    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;

    // Store the initial touch positions for reference
    lastX.current = clientX;
    lastY.current = clientY;
  };

  const handleTouchEnd = (e) => {
    e.stopPropagation();
    e.preventDefault();
    setIsRotating(false);
  };

  const handleTouchMove = (e) => {
    e.stopPropagation();
    e.preventDefault();

    if (isRotating) {
      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const clientY = e.touches ? e.touches[0].clientY : e.clientY;

      // Calculate deltas for both X and Y movement
      const deltaX = (clientX - lastX.current) / viewport.width;
      const deltaY = (clientY - lastY.current) / viewport.height;

      // Update the island's rotation based on touch movement
      group.current.rotation.y += deltaX * 0.01 * Math.PI; // Y-axis rotation
      group.current.rotation.x += deltaY * 0.01 * Math.PI; // X-axis rotation

      // Update references for the last clientX and clientY positions
      lastX.current = clientX;
      lastY.current = clientY;

      // Update the rotation speed
      rotationSpeed.current = {
        x: deltaX * 0.01 * Math.PI,
        y: deltaY * 0.01 * Math.PI,
      };
    }
  };
  useEffect(() => {
    // Add event listeners for pointer and keyboard events
    const canvas = gl.domElement;
    canvas.addEventListener("pointerdown", handlePointerDown);
    canvas.addEventListener("pointerup", handlePointerUp);
    canvas.addEventListener("pointermove", handlePointerMove);
    canvas.addEventListener("touchstart", handleTouchStart);
    canvas.addEventListener("touchend", handleTouchEnd);
    canvas.addEventListener("touchmove", handleTouchMove);
    // Remove event listeners when component unmounts
    return () => {
      canvas.removeEventListener("pointerdown", handlePointerDown);
      canvas.removeEventListener("pointerup", handlePointerUp);
      canvas.removeEventListener("pointermove", handlePointerMove);
      canvas.removeEventListener("touchstart", handleTouchStart);
      canvas.removeEventListener("touchend", handleTouchEnd);
      canvas.removeEventListener("touchmove", handleTouchMove);
    };
  }, [gl, handlePointerDown, handlePointerUp, handlePointerMove]);
// This function is called on each frame update
useFrame(() => {
  // If not rotating, apply damping to slow down the rotation (smoothly)
  if (!isRotating) {
    // Apply damping factor to both x and y rotation speeds
    rotationSpeed.current.x *= dampingFactor;
    rotationSpeed.current.y *= dampingFactor;

    // Stop rotation when speeds are very small
    if (Math.abs(rotationSpeed.current.x) < 0.001) {
      rotationSpeed.current.x = 0;
    }
    if (Math.abs(rotationSpeed.current.y) < 0.001) {
      rotationSpeed.current.y = 0;
    }

    // Apply the damped rotation speeds to the island's rotation
    group.current.rotation.x += rotationSpeed.current.x;
    group.current.rotation.y += rotationSpeed.current.y;
  } else {
    // When rotating, determine the current stage based on island's Y-axis orientation
    const rotationY = group.current.rotation.y;

    /**
     * Normalize the Y rotation value to ensure it stays within the range [0, 2 * Math.PI].
     * This prevents issues with very large or negative rotation values.
     */
    const normalizedRotationY =
      ((rotationY % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);

    // Set the current stage based on the island's Y-axis orientation
    switch (true) {
      case normalizedRotationY >= 5.45 && normalizedRotationY <= 5.85:
        setCurrentStage(4);
        break;
      case normalizedRotationY >= 0.85 && normalizedRotationY <= 1.3:
        setCurrentStage(3);
        break;
      case normalizedRotationY >= 2.4 && normalizedRotationY <= 2.6:
        setCurrentStage(2);
        break;
      case normalizedRotationY >= 4.25 && normalizedRotationY <= 4.75:
        setCurrentStage(1);
        break;
      default:
        setCurrentStage(null);
    }
  }
});
useEffect(() => {
  if (stageClik) {
    // Define target rotation based on stageClik
    const targetYRotation = {
      1: Math.PI / 2, // Example values for each stage
      2: Math.PI,
      3: Math.PI / 4,
      4: (7 * Math.PI)/4
    }[stageClik];

    // Animate rotation smoothly
    group.current.rotation.y = targetYRotation;
  }
}, [stageClik]);
 
  const group = useRef();
  const { nodes, materials, animations } = useGLTF(potboyscene);
  const { actions } = useAnimations(animations, group);
  useEffect(() => {
    if (actions[currentAnimation]) {
      actions[currentAnimation].play();
    }
  }, [actions, currentAnimation]);
  useEffect(() => {
    if (actions[currentAnimation]) {
      actions[currentAnimation].play();
    }

    // Calculate the bounding box and bounding sphere
    const boundingBox = new Box3().setFromObject(group.current);
    const boundingSphere = new Sphere();
    boundingBox.getBoundingSphere(boundingSphere);

    // Log the center and radius of the bounding sphere
    console.log("Bounding Sphere Center:", boundingSphere.center);
    console.log("Bounding Sphere Radius:", boundingSphere.radius);
  }, [actions, currentAnimation]);
  return (
    <group ref={group} {...props}   dispose={null}>
      <group name="Sketchfab_Scene">
        <group name="Sketchfab_model" rotation={[-Math.PI / 2, 0, 0]}>
          <group
            name="JarBairn_Walk001fbx"
            rotation={[Math.PI / 2, 0, 0]}
            scale={0.01}
          >
            <group name="Object_2">
              <group name="RootNode">
                <group name="Jar_Bairn_geo" position={[0, 4.9983, 0]} />
                <group
                  name="Armature"
                  position={[0, 20.4351, 0]}
                  rotation={[-Math.PI / 2, 0, 0]}
                  scale={61.7104}
                >
                  <group name="Object_6">
                    <primitive object={nodes._rootJoint} />
                    <skinnedMesh
                      name="Object_9"
                      geometry={nodes.Object_9.geometry}
                      material={materials["JarBairn_MAT.1002"]}
                      skeleton={nodes.Object_9.skeleton}
                    />
                    <skinnedMesh
                      name="Object_10"
                      geometry={nodes.Object_10.geometry}
                      material={materials["JarBairn_MAT.1003"]}
                      skeleton={nodes.Object_10.skeleton}
                    />
                    <skinnedMesh
                      name="Object_11"
                      geometry={nodes.Object_11.geometry}
                      material={materials["JarBairn_MAT.1001"]}
                      skeleton={nodes.Object_11.skeleton}
                    />
                    <skinnedMesh
                      name="Object_12"
                      geometry={nodes.Object_12.geometry}
                      material={materials["JarBairn_MAT.1004"]}
                      skeleton={nodes.Object_12.skeleton}
                    />
                    <group name="Object_8" position={[0, 4.9983, 0]} />
                  </group>
                </group>
              </group>
            </group>
          </group>
        </group>
      </group>
    </group>
  );
};

useGLTF.preload("/scene.gltf");
export default Potboy;
